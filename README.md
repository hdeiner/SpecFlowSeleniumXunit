This project is a lot like https://github.com/hdeiner/Cucumber_Selenium_PageObject_Sample, in that it wants to reinforce a more correct way to accomplish Selenium testing driven by SpecFlow (Cucumber for Windows) to accomplish user interface testing for web applications, where the testers are more comfortable using Visual Studio in C# under Windows.

Again, the goals (from the Cucumber for Java project mentioned) are:
In particular, the following is demonstrated:

- Declarative and Expressive Gherkin.  When you’re writing Cucumber features, 
you have to be very careful to make readability your main goal. Otherwise, a 
reader can easily feel more like they’re reading a computer program than a 
specification document, which is something we want you to try to avoid at all 
costs. After all, if your features aren’t easy for non-programmers to read, you 
might as well just be writing your tests in plain old code. Some of this has to
do with being expressive with the use of domain language.  And some of this has to
with saying why and what, and hiding the hows of testing for developers exclusively.
- Page Objects: The use of object oriented concepts will make your test code less 
fragile.  And, your code will be more maintainable.  This code, while not perfect by
any means, demonstrates the use of Open/Closed principles, Factory Method patterns, 
and some Single Responsibility principles.  Along with good old fashion object 
hierarchies.  Thinking less imperatively and more declaratively in your code has huge
benefits in terms of readability!
- Selenium fluentWaits.  Way too much testing code includes hard Thread.Sleep(xxx) 
waits coded directly inline.  This is done to allow non-deterministic client test to 
out of band broswer code to synchronize.  Unhappily, no matter how big of a wait you 
code, one day, you will find that it wasn't enough.  Furthermore, your test code will 
now always run as slowly as the sum of all the waits!  fluentWaits are the solution.  
- Informative Builds.  We need to transition away from project plans, estimation, and 
tracking actuals against estimates to plan projects better.  And, we need better ways 
of knowing exactly what fails in regression suites, so we can zero in on improving our 
code where it's needed.  Better automated reporting is what's called for!

You will notice that the Gherkin here is slightly different.  Having inline data tables in SpecFlow is more difficult, and I wanted to complete this project, rather than get driven into a rathole on that issue.

I turned on Screenshots in this project.  Take a look at the TestResults directory after you run the SpecFlow tests.  You'll see an HTML report generated by SpecFlowRunner, as well as screenshots of each test result.

You will also notice that the project was enhanced to include support for IE.  Since this work was done on a Windows 10 machine, that meant IE 11.  Be sure to follow all the configuration detailed at https://github.com/SeleniumHQ/selenium/wiki/InternetExplorerDriver#required-configuration to allow IE11 to function as a Selenium Test browser.  This turned out to be an unmitigated disaster.  I commented out the feature file outline samples that would otherwise invoke that browser.  Your mileage may vary.  ON THE OTHER HAND, the support for the Edge browser is EXCELLENT and is THE FASTEST Selenium testing that I've seen on any system!
